<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Callbacks and Lambdas in CMake &mdash; CMakeDev 1.0.0alpha documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Best CMake Practices" href="best_practices.html" />
    <link rel="prev" title="Writing Your Own CMake Functions" href="writing_functions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            CMakeDev
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html">About CMake Packaging Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to CMakePP</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Developer Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../conventions/index.html">Conventions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">CMake Language</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="control_flow.html">Control Flow Statements</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_functions.html">Writing Your Own CMake Functions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Callbacks and Lambdas in CMake</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dispatch">Dispatch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializer-function-pattern">Initializer Function Pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visitor-pattern">Visitor Pattern</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="best_practices.html">Best CMake Practices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Getting Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CMakeDev</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Developer Documentation</a></li>
          <li class="breadcrumb-item"><a href="index.html">CMake Language</a></li>
      <li class="breadcrumb-item active">Callbacks and Lambdas in CMake</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/developer/cmake/callbacks.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="callbacks-and-lambdas-in-cmake">
<h1>Callbacks and Lambdas in CMake<a class="headerlink" href="#callbacks-and-lambdas-in-cmake" title="Permalink to this heading"></a></h1>
<p>Callbacks are functions which are provided to another function as input. This
differs from a typical nested function call in that it is possible to change the
“value” of a callback at runtime. Put another way, nested function calls can be
thought of as hard-coded callbacks. Lambdas are functions that are written
on-the-fly and using the runtime state of the program in their definitions.
Lambdas are almost always used as callbacks hence their relevance to the present
discussion. Supporting callbacks and lambdas greatly facilitates generic
programming. CMake does not natively support callbacks, but it does natively
support lambdas (users can declare functions and macros almost anywhere);
however, without callback support these lambdas must be run in-place and can not
be passed to functions, which largely defeats the purpose of a lambda. This
chapter focuses on techniques to implement callbacks in CMake.</p>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h2>
<p>Before we describe some of the solutions out there it is worth explicitly noting
some points about the CMake language so that we understand the limitations the
patterns are constrained by.</p>
<section id="cmake-function-names-can-not-be-variables">
<h3>CMake Function Names Can NOT be Variables<a class="headerlink" href="#cmake-function-names-can-not-be-variables" title="Permalink to this heading"></a></h3>
<p>As the subsection title says CMake does not allow function names to be
variables. Specifically, the following is <strong>NOT</strong> valid CMake:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>function(my_fxn1)
endfunction()

function(my_fxn2)
endfunction()

set(fxn_name my_fxn1)
if(some_condition)
    set(fxn_name my_fxn2)
endif()

${fxn_name}()
</pre></div>
</div>
<p>Here the intent is that we default to calling <code class="docutils literal notranslate"><span class="pre">my_fxn1</span></code>, but if a certain
condition is met, <code class="docutils literal notranslate"><span class="pre">some_condition</span></code>, we want to call <code class="docutils literal notranslate"><span class="pre">my_fxn2</span></code>. Everything is
valid CMake until the last line; CMake does <strong>NOT</strong> allow us to get the
function’s name from a variable. CMake also does not allow any part of the
function’s name to come from a variable, <em>i.e.</em>, this is <strong>NOT</strong> valid either:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>function(is_valid_cxx_code code)
    # Check if ${code} is valid C++
endfunction()

function(is_valid_python_code code)
    # Check if ${code} is valid Python
endfunction()

set(lang cxx)

is_valid_${lang}_code(&quot;x = [y in range(3)]&quot;)
</pre></div>
</div>
<p>If by some chance either of these restrictions are removed in a later release of
CMake this chapter becomes nothing more than a historical curiosity.</p>
</section>
<section id="cmake-s-include-command">
<h3>CMake’s include Command<a class="headerlink" href="#cmake-s-include-command" title="Permalink to this heading"></a></h3>
<p>While there is a tendency to group all calls to CMake’s native <code class="docutils literal notranslate"><span class="pre">include</span></code>
command at the top of a file, the reality is these calls can be used almost
anywhere. Of particular relevance <code class="docutils literal notranslate"><span class="pre">include</span></code> can be used in a function like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">function</span><span class="p">(</span><span class="s">my_fxn</span><span class="p">)</span>
<span class="w">    </span><span class="nb">include</span><span class="p">(</span><span class="s">CMakeDependentOption</span><span class="p">)</span>
<span class="w">    </span><span class="nb">cmake_dependent_option</span><span class="p">(</span><span class="s">...</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="nb">my_fxn</span><span class="p">()</span>
</pre></div>
</div>
<p>This code writes a function, which includes the <code class="docutils literal notranslate"><span class="pre">CMakeDependentOption</span></code> module
(the module facilitates declaring options that depend on other options) and then
calls the <code class="docutils literal notranslate"><span class="pre">cmake_dependent_option</span></code> function introduced by that module. Next
this code snippet calls the function we just defined.</p>
<p>The arguments to <a href="#id1"><span class="problematic" id="id2">``</span></a>include``can be a variable. For example:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">file_to_include</span><span class="w"> </span><span class="s">a/path/to/a/CMake/module</span><span class="p">)</span>
<span class="nb">include</span><span class="p">(</span><span class="o">${</span><span class="nv">file_to_include</span><span class="o">}</span><span class="p">)</span>
</pre></div>
</div>
<p>is perfectly acceptable CMake code.</p>
</section>
<section id="cmake-s-function-command">
<h3>CMake’s Function Command<a class="headerlink" href="#cmake-s-function-command" title="Permalink to this heading"></a></h3>
<p>Along the same lines of the <code class="docutils literal notranslate"><span class="pre">include</span></code> subsection above, it is worth noting
that when defining a function the name can be a variable. For example:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>set(fxn_name &quot;my_fxn&quot;)
function(${fxn_name})
    ...
endfunction()
</pre></div>
</div>
<p>allows us to declare a function with a variable name. In fact, the entire
signature can be a variable:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>set(fxn_sig my_fxn arg1 arg2)
function(${fxn_sig})
    ...
endfunction()
</pre></div>
</div>
<p>declares a function <code class="docutils literal notranslate"><span class="pre">my_fxn</span></code> which takes two positional arguments named
<code class="docutils literal notranslate"><span class="pre">arg1</span></code> and <code class="docutils literal notranslate"><span class="pre">arg2</span></code>.</p>
<p>That said, CMake will not allow the body of the <code class="docutils literal notranslate"><span class="pre">function</span></code> command to come
from a variable, in other words the following is <strong>NOT</strong> valid CMake:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>set(fxn_contents &quot;message(hello world)&quot;)
function(my_fxn)
    ${fxn_contents}
endfunction()
</pre></div>
</div>
</section>
</section>
<section id="dispatch">
<h2>Dispatch<a class="headerlink" href="#dispatch" title="Permalink to this heading"></a></h2>
<p>The dispatch pattern can be used for callbacks when the list of possible
callbacks is explicitly known and can be enumerated while writing the file. Say
we have three possible functions we may want to call <code class="docutils literal notranslate"><span class="pre">fxn1</span></code>, <code class="docutils literal notranslate"><span class="pre">fxn2</span></code>, and
<code class="docutils literal notranslate"><span class="pre">fxn3</span></code>, the dispatch pattern looks like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">function</span><span class="p">(</span><span class="s">call_a_fxn</span><span class="w"> </span><span class="s">fxn_name</span><span class="p">)</span>
<span class="w">    </span><span class="nb">if</span><span class="p">(</span><span class="s2">&quot;${fxn_name}&quot;</span><span class="w"> </span><span class="s">STREQUAL</span><span class="w"> </span><span class="s2">&quot;fxn1&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="nb">fxn1</span><span class="p">()</span>
<span class="w">    </span><span class="nb">elseif</span><span class="p">(</span><span class="s2">&quot;${fxn_name}&quot;</span><span class="w"> </span><span class="s">STREQUAL</span><span class="w"> </span><span class="s2">&quot;fxn2&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="nb">fxn2</span><span class="p">()</span>
<span class="w">    </span><span class="nb">elseif</span><span class="p">(</span><span class="s2">&quot;${fxn_name}&quot;</span><span class="w"> </span><span class="s">STREQUAL</span><span class="w"> </span><span class="s2">&quot;fxn3&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="nb">fxn3</span><span class="p">()</span>
<span class="w">    </span><span class="nb">else</span><span class="p">()</span>
<span class="w">        </span><span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span><span class="w"> </span><span class="s2">&quot;Function ${fxn_name} not found.&quot;</span>
<span class="w">    </span><span class="s">endif(</span><span class="p">)</span>
<span class="w"> </span><span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Call fxn2 for example</span>
<span class="nb">call_a_fxn</span><span class="p">(</span><span class="s">fxn2</span><span class="p">)</span>
</pre></div>
</div>
<p>The code should be self-explanatory. Arguments to functions in the dispatch
pattern are best treated as kwargs unless all functions have the same exact
signature.</p>
<p>Admittedly this pattern does not actually implement callbacks, rather it
simulates them. By itself this pattern is only feasible when the number of
“callbacks” is small and known when <code class="docutils literal notranslate"><span class="pre">call_a_fxn</span></code> is being written. It’s
important to note that this solution introduces a layer of indirection, but does
not require writing a file to disk (you likely will have to read include files
for the various functions you dispatch among).</p>
</section>
<section id="initializer-function-pattern">
<h2>Initializer Function Pattern<a class="headerlink" href="#initializer-function-pattern" title="Permalink to this heading"></a></h2>
<p>I first saw this named pattern in the
<a class="reference external" href="https://github.com/toeb/cmakepp">CMake++</a> library. The essence of this
pattern is that we generate an implementation file on-the-fly, and then include
that file run the contents. In CMake++ the pattern works by assuming we have the
code we want to call in a string. CMake++ then defines a function <code class="docutils literal notranslate"><span class="pre">eval</span></code> like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span>function(eval contents)
    set(temp_file path/where/temp/file/should/go)

    file(
        WRITE ${temp_file}
        &quot;function(eval contents)
             file(WRITE ${temp_file} \&quot;\${contents}\&quot;)
             include(${temp_file})
         endfunction()&quot;
    )
    include(${temp_file})
    eval(&quot;${contents}&quot;)
endfunction()
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">eval</span></code> can then be used like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;message(\&quot;</span><span class="s">hello</span><span class="w"> </span><span class="s">world\</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This code is actually quite dense, this note provides a breakdown of how it
works.</p>
<ol class="arabic simple">
<li><p>User calls <code class="docutils literal notranslate"><span class="pre">eval</span></code> with the contents they want to run.</p>
<ul class="simple">
<li><p>Call to <code class="docutils literal notranslate"><span class="pre">eval</span></code> happens in scope <code class="docutils literal notranslate"><span class="pre">A</span></code></p></li>
<li><p>Inside <code class="docutils literal notranslate"><span class="pre">eval</span></code> is scope <code class="docutils literal notranslate"><span class="pre">A::B</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A::eval</span></code> writes a second version of <code class="docutils literal notranslate"><span class="pre">eval</span></code> to a temporary file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A::eval</span></code> includes the temporary file</p>
<ul class="simple">
<li><p>Including file runs it, defining a new version of <code class="docutils literal notranslate"><span class="pre">eval</span></code> in scope
<code class="docutils literal notranslate"><span class="pre">A::B</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A::eval</span></code> runs <code class="docutils literal notranslate"><span class="pre">A::B::eval</span></code></p>
<ul class="simple">
<li><p>Scope inside <code class="docutils literal notranslate"><span class="pre">A::B::eval</span></code> is <code class="docutils literal notranslate"><span class="pre">A::B::C</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A::B::eval</span></code> writes the contents to a temporary file</p>
<ul class="simple">
<li><p>Use the same temporary file because we don’t need the original anymore</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A::B::eval</span></code> includes the new temporary file</p></li>
<li><p>The user’s contents run in scope <code class="docutils literal notranslate"><span class="pre">A::B::C</span></code></p>
<ul class="simple">
<li><p>Means <code class="docutils literal notranslate"><span class="pre">set(...</span> <span class="pre">PARENT_SCOPE)</span></code> only returns to scope <code class="docutils literal notranslate"><span class="pre">A::B</span></code></p></li>
</ul>
</li>
</ol>
<p>You may be curious what happens if you do not nest the file writes in
<code class="docutils literal notranslate"><span class="pre">eval</span></code>. If you do not nest the file writes then only first call will work.
For example, without nesting the file writes:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;message(\&quot;</span><span class="s">hello</span><span class="w"> </span><span class="s">world\</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
<span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;message(\&quot;</span><span class="s">42\</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>will print <code class="docutils literal notranslate"><span class="pre">&quot;hello</span> <span class="pre">world&quot;</span></code> twice. This is because <code class="docutils literal notranslate"><span class="pre">A::B::eval</span></code>’s
definition actually replaces <code class="docutils literal notranslate"><span class="pre">A::eval</span></code>.</p>
</div>
<p>This pattern is expensive in terms of computational resources as it involves two
file reads and two file writes. It also requires special attention if it is
going to be used in parallel as it is quite easy for multiple calls to overwrite
each other’s temporary files. As written the first call to <code class="docutils literal notranslate"><span class="pre">eval</span></code> can not
return variables (subsequent calls can) since the content is actually run two
scopes down.</p>
<p>It is possible to simplify the above implementation:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">function</span><span class="p">(</span><span class="s">eval</span><span class="w"> </span><span class="s">contents</span><span class="p">)</span>
<span class="w">    </span><span class="nb">set</span><span class="p">(</span><span class="s">temp_file</span><span class="w"> </span><span class="s">path/for/temporary/file</span><span class="p">)</span>

<span class="w">    </span><span class="nb">file</span><span class="p">(</span><span class="s">WRITE</span><span class="w"> </span><span class="o">${</span><span class="nv">temp_file</span><span class="o">}</span><span class="w"> </span><span class="s2">&quot;${contents}&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nb">include</span><span class="p">(</span><span class="o">${</span><span class="nv">temp_file</span><span class="o">}</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>This implementation does the same thing as CMake++’s <code class="docutils literal notranslate"><span class="pre">eval</span></code> with less function
calls and I/O. This implementation also has the added benefit of only
introducing one nested scope on all calls, thus we can return variables like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;set(x \&quot;</span><span class="s">hello</span><span class="w"> </span><span class="s">world\</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">&quot;x == ${x}&quot;</span><span class="p">)</span><span class="w">  </span><span class="c"># Will print &quot;x == hello world&quot;</span>
</pre></div>
</div>
<p>A major disadvantage of the <code class="docutils literal notranslate"><span class="pre">eval</span></code> calls (both CMake++ and our optimized form)
is that the code to run has to be provided as a string. As shown in the code
examples, this means that special characters, like <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">;</span></code>, will need
escaped, which is error-prone and tedious.</p>
</section>
<section id="visitor-pattern">
<h2>Visitor Pattern<a class="headerlink" href="#visitor-pattern" title="Permalink to this heading"></a></h2>
<p>This pattern works by agreeing on the name of the callback and its signature.
For example, say we are writing a function <code class="docutils literal notranslate"><span class="pre">my_fxn</span></code> which generates two
variables and needs to compare them. Since it is reasonable that the user may
want to use a custom comparison operation, we decide that our function should
take a callback to do the comparison. By convention we agree that the callback
is named <code class="docutils literal notranslate"><span class="pre">compare_my_variables</span></code> and has a signature like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">compare_my_variables</span><span class="p">(</span><span class="s">&lt;result&gt;</span><span class="w"> </span><span class="s">&lt;var1&gt;</span><span class="w"> </span><span class="s">&lt;var2&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>we can then write our <code class="docutils literal notranslate"><span class="pre">my_fxn</span></code> function like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">function</span><span class="p">(</span><span class="s">my_fxn</span><span class="w"> </span><span class="s">comparison_file</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Generate these variables somehow</span>
<span class="w">    </span><span class="nb">set</span><span class="p">(</span><span class="s">var1</span><span class="w"> </span><span class="s">foo</span><span class="p">)</span>
<span class="w">    </span><span class="nb">set</span><span class="p">(</span><span class="s">var2</span><span class="w"> </span><span class="s">bar</span><span class="p">)</span>
<span class="w">    </span><span class="nb">include</span><span class="p">(</span><span class="o">${</span><span class="nv">comparison_file</span><span class="o">}</span><span class="p">)</span>
<span class="w">    </span><span class="nb">compare_my_variables</span><span class="p">(</span><span class="s">result</span><span class="w"> </span><span class="o">${</span><span class="nv">var1</span><span class="o">}</span><span class="w"> </span><span class="o">${</span><span class="nv">var2</span><span class="o">}</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>and this is used like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">my_fxn</span><span class="p">(</span><span class="s">path/to/comparison_file</span><span class="p">)</span>
</pre></div>
</div>
<p>If we think of the CMake module as an object and the function in the module as a
method, this pattern looks a lot like the visitor pattern (one could argue it is
actually duck typing, since the visitor pattern usually has a common base class,
but oh well).</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="writing_functions.html" class="btn btn-neutral float-left" title="Writing Your Own CMake Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="best_practices.html" class="btn btn-neutral float-right" title="Best CMake Practices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020, 2022-2023, Authors of CMakePP.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>